% generated by Ott 0.28 from: GTFL.ott
\newcommand{\ottdrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\ottdrulename{#4}}}
\newcommand{\ottusedrule}[1]{\[#1\]}
\newcommand{\ottpremise}[1]{ #1 \\}
\newenvironment{ottdefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]}{}
\newenvironment{ottfundefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]\begin{displaymath}\begin{array}{l}}{\end{array}\end{displaymath}}
\newcommand{\ottfunclause}[2]{ #1 \equiv #2 \\}
\newcommand{\ottnt}[1]{\mathit{#1}}
\newcommand{\ottmv}[1]{\mathit{#1}}
\newcommand{\ottkw}[1]{\mathbf{#1}}
\newcommand{\ottsym}[1]{#1}
\newcommand{\ottcom}[1]{\text{#1}}
\newcommand{\ottdrulename}[1]{\textsc{#1}}
\newcommand{\ottcomplu}[5]{\overline{#1}^{\,#2\in #3 #4 #5}}
\newcommand{\ottcompu}[3]{\overline{#1}^{\,#2<#3}}
\newcommand{\ottcomp}[2]{\overline{#1}^{\,#2}}
\newcommand{\ottgrammartabular}[1]{\begin{supertabular}{llcllllll}#1\end{supertabular}}
\newcommand{\ottmetavartabular}[1]{\begin{supertabular}{ll}#1\end{supertabular}}
\newcommand{\ottrulehead}[3]{$#1$ & & $#2$ & & & \multicolumn{2}{l}{#3}}
\newcommand{\ottprodline}[6]{& & $#1$ & $#2$ & $#3 #4$ & $#5$ & $#6$}
\newcommand{\ottfirstprodline}[6]{\ottprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\ottlongprodline}[2]{& & $#1$ & \multicolumn{4}{l}{$#2$}}
\newcommand{\ottfirstlongprodline}[2]{\ottlongprodline{#1}{#2}}
\newcommand{\ottbindspecprodline}[6]{\ottprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\ottprodnewline}{\\}
\newcommand{\ottinterrule}{\\[5.0mm]}
\newcommand{\ottafterlastrule}{\\}
\newcommand{\ottmetavars}{
\ottmetavartabular{
 $ \mathit{x} ,\, \mathit{y} ,\, \mathit{z} ,\, \mathit{c} $ & \ottcom{Symbols from some infinite set} \\
 $ i $ & \ottcom{Indices (ott artifact, please ignore)} \\
}}

\newcommand{\ottn}{
\ottrulehead{\ottnt{n}}{::=}{\ottcom{Natural Numbers}}}

\newcommand{\ottb}{
\ottrulehead{b}{::=}{\ottcom{Booleans}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{true}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottkw{false}}{}{}{}{}}

\newcommand{\otte}{
\ottrulehead{\ottnt{e}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{\mathit{x}}{}{}{}{\ottcom{Variables}}\ottprodnewline
\ottprodline{|}{b}{}{}{}{\ottcom{Booleans}}\ottprodnewline
\ottprodline{|}{\ottnt{n}}{}{}{}{\ottcom{Natural Numbers}}\ottprodnewline
\ottprodline{|}{\lambda  \mathit{x}  \ottsym{:}  \ottnt{T}  \ldotp  \ottnt{e}}{}{}{}{\ottcom{Functions}}\ottprodnewline
\ottprodline{|}{ \ottnt{e_{{\mathrm{1}}}} \  \ottnt{e_{{\mathrm{2}}}} }{}{}{}{\ottcom{Function Application}}\ottprodnewline
\ottprodline{|}{\ottnt{e_{{\mathrm{1}}}}  \ottsym{+}  \ottnt{e_{{\mathrm{2}}}}}{}{}{}{\ottcom{Addition}}\ottprodnewline
\ottprodline{|}{\ottnt{e_{{\mathrm{1}}}}  \stackrel{?}{=}  \ottnt{e_{{\mathrm{2}}}}}{}{}{}{\ottcom{Number Equality Test}}\ottprodnewline
\ottprodline{|}{\ottkw{if} \, \ottnt{e_{{\mathrm{1}}}} \, \ottkw{then} \, \ottnt{e_{{\mathrm{2}}}} \, \ottkw{else} \, \ottnt{e_{{\mathrm{3}}}}}{}{}{}{\ottcom{Conditionals}}\ottprodnewline
\ottprodline{|}{ \langle  \ottnt{e_{{\mathrm{1}}}} ,  \ottnt{e_{{\mathrm{2}}}}  \rangle }{}{}{}{\ottcom{Tuples}}\ottprodnewline
\ottprodline{|}{\pi_1  \ottnt{e}}{}{}{}{\ottcom{Tuple First Projection}}\ottprodnewline
\ottprodline{|}{\pi_2  \ottnt{e}}{}{}{}{\ottcom{Tuple Second Projection}}\ottprodnewline
\ottprodline{|}{\varepsilon \, \ottnt{e}}{}{}{}{\ottcom{Evidence Ascription}}\ottprodnewline
\ottprodline{|}{\ottkw{error}}{}{}{}{\ottcom{Runtime Type Error}}}

\newcommand{\ottO}{
\ottrulehead{\ottnt{O}}{::=}{\ottcom{Observable values}}\ottprodnewline
\ottfirstprodline{|}{b}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{n}}{}{}{}{}}

\newcommand{\ottr}{
\ottrulehead{r}{::=}{\ottcom{Raw Irreducable (closed) terms (i.e. not ascribed with)}}\ottprodnewline
\ottfirstprodline{|}{b}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{n}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\lambda  \mathit{x}  \ottsym{:}  \ottnt{T}  \ldotp  \ottnt{e}}{}{}{}{\ottcom{Functions}}\ottprodnewline
\ottprodline{|}{ \langle  v_{{\mathrm{1}}} ,  v_{{\mathrm{2}}}  \rangle }{}{}{}{}}

\newcommand{\ottv}{
\ottrulehead{v}{::=}{\ottcom{Irreducable (closed) terms}}\ottprodnewline
\ottfirstprodline{|}{\varepsilon \, r}{}{}{}{}\ottprodnewline
\ottprodline{|}{b}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{n}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\lambda  \mathit{x}  \ottsym{:}  \ottnt{T}  \ldotp  \ottnt{e}}{}{}{}{\ottcom{Functions}}\ottprodnewline
\ottprodline{|}{ \langle  v_{{\mathrm{1}}} ,  v_{{\mathrm{2}}}  \rangle }{}{}{}{}}

\newcommand{\ottep}{
\ottrulehead{\varepsilon}{::=}{}\ottprodnewline
\ottfirstprodline{|}{ \{  \ottnt{T}  \} }{}{}{}{}}

\newcommand{\ottT}{
\ottrulehead{\ottnt{T}}{::=}{\ottcom{Types}}\ottprodnewline
\ottfirstprodline{|}{ \mathsf{Nat} }{}{}{}{}\ottprodnewline
\ottprodline{|}{ \mathsf{Bool} }{}{}{}{}\ottprodnewline
\ottprodline{|}{ \ottnt{T_{{\mathrm{1}}}} \to \ottnt{T_{{\mathrm{2}}}} }{}{}{}{}\ottprodnewline
\ottprodline{|}{ \ottnt{T_{{\mathrm{1}}}} \times \ottnt{T_{{\mathrm{2}}}} }{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{\mbox{?}}}{}{}{}{}}

\newcommand{\ottGamma}{
\ottrulehead{\Gamma}{::=}{\ottcom{Environments}}\ottprodnewline
\ottfirstprodline{|}{ \cdot }{}{}{}{}\ottprodnewline
\ottprodline{|}{\Gamma  \ottsym{,}  \ottsym{(}  \mathit{x}  \ottsym{:}  \ottnt{T}  \ottsym{)}}{}{}{}{}}

\newcommand{\ottC}{
\ottrulehead{\ottnt{C}}{::=}{\ottcom{evaluation context}}\ottprodnewline
\ottfirstprodline{|}{\ottkw{\_\_} \, \ottnt{e}}{}{}{}{}\ottprodnewline
\ottprodline{|}{v \, \ottkw{\_\_}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{(} \, \ottkw{\_\_} \, \ottsym{,}  \ottnt{e}  \ottsym{)}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{(}  v  \ottsym{,} \, \ottkw{\_\_} \, \ottsym{)}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{(}  \pi_1 \, \ottkw{\_\_} \, \ottsym{)}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottsym{(}  \pi_2 \, \ottkw{\_\_} \, \ottsym{)}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\varepsilon \, \ottkw{\_\_}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottkw{\_\_} \, \ottsym{+}  \ottnt{e_{{\mathrm{1}}}}}{}{}{}{}\ottprodnewline
\ottprodline{|}{v  \ottsym{+} \, \ottkw{\_\_}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottkw{\_\_} \, \stackrel{?}{=}  \ottnt{e_{{\mathrm{1}}}}}{}{}{}{}\ottprodnewline
\ottprodline{|}{v  \stackrel{?}{=} \, \ottkw{\_\_}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottkw{if} \, \ottkw{\_\_} \, \ottkw{then} \, \ottnt{e_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{e_{{\mathrm{2}}}}}{}{}{}{}}

\newcommand{\ottu}{
\ottrulehead{\ottnt{u}  ,\ \ottnt{k}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{\mathit{x}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottnt{n}}{}{}{}{}\ottprodnewline
\ottprodline{|}{b}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottkw{fix} \, \mathit{x} \, \ottnt{u}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\lambda  \mathit{x_{{\mathrm{1}}}} \, ... \, \mathit{x_{\ottmv{i}}}  \ldotp  \ottnt{t}}{}{}{}{}\ottprodnewline
\ottprodline{|}{ \langle  \ottnt{u_{{\mathrm{1}}}} ,  \ottnt{u_{{\mathrm{2}}}} \rangle }{}{}{}{}}

\newcommand{\ottd}{
\ottrulehead{\ottnt{d}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{\mathit{x}  \ottsym{:=}  \ottnt{u}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\mathit{x}  \ottsym{:=}  \pi_1  \ottnt{u}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\mathit{x}  \ottsym{:=}  \pi_2  \ottnt{u}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\mathit{x}  \ottsym{:=}  \ottnt{u_{{\mathrm{1}}}}  \ottsym{+}  \ottnt{u_{{\mathrm{2}}}}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\mathit{x}  \ottsym{:=}  \ottnt{u_{{\mathrm{1}}}}  \stackrel{?}{=}  \ottnt{u_{{\mathrm{2}}}}}{}{}{}{}}

\newcommand{\ottt}{
\ottrulehead{\ottnt{t}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{v}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottkw{let} \, \ottnt{d} \, \ottkw{in} \, \ottnt{t}}{}{}{}{}\ottprodnewline
\ottprodline{|}{ \ottnt{u} ( \ottnt{arg} ) }{}{}{}{}\ottprodnewline
\ottprodline{|}{ \ottkw{ if }\  \ottnt{u} \ \ottkw{ then }\  \ottnt{t_{{\mathrm{1}}}} \ \ottkw{ else }\  \ottnt{t_{{\mathrm{2}}}} }{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottkw{halt} \, \ottsym{[}  \ottnt{u}  \ottsym{]}}{}{}{}{}\ottprodnewline
\ottprodline{|}{\ottkw{error}}{}{}{}{}}

\newcommand{\ottarg}{
\ottrulehead{\ottnt{arg}}{::=}{}\ottprodnewline
\ottfirstprodline{|}{\ottnt{u_{{\mathrm{1}}}}  \ottsym{,} \, ... \, \ottsym{,}  \ottnt{u_{\ottmv{i}}}}{}{}{}{}}

\newcommand{\ottgrammar}{\ottgrammartabular{
\ottn\ottinterrule
\ottb\ottinterrule
\otte\ottinterrule
\ottO\ottinterrule
\ottr\ottinterrule
\ottv\ottinterrule
\ottep\ottinterrule
\ottT\ottinterrule
\ottGamma\ottinterrule
\ottC\ottinterrule
\ottu\ottinterrule
\ottd\ottinterrule
\ottt\ottinterrule
\ottarg\ottafterlastrule
}}

% defnss
% defns Semantics
%% defn Red
\newcommand{\ottdruleRedIfTrue}[1]{\ottdrule[#1]{%
}{
\ottkw{if} \, \ottkw{true} \, \ottkw{then} \, \ottnt{e_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{e_{{\mathrm{2}}}}  \longrightarrow  \ottnt{e_{{\mathrm{1}}}}}{%
{\ottdrulename{RedIfTrue}}{}%
}}


\newcommand{\ottdruleRedIfFalse}[1]{\ottdrule[#1]{%
}{
\ottkw{if} \, \ottkw{false} \, \ottkw{then} \, \ottnt{e_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{e_{{\mathrm{2}}}}  \longrightarrow  \ottnt{e_{{\mathrm{2}}}}}{%
{\ottdrulename{RedIfFalse}}{}%
}}


\newcommand{\ottdruleRedIfEv}[1]{\ottdrule[#1]{%
\ottpremise{\ottkw{if} \, b \, \ottkw{then} \, \ottnt{e_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{e_{{\mathrm{2}}}}  \longrightarrow  \ottnt{e}}%
}{
\ottkw{if} \, \varepsilon \, b \, \ottkw{then} \, \ottnt{e_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{e_{{\mathrm{2}}}}  \longrightarrow  \ottnt{e}}{%
{\ottdrulename{RedIfEv}}{}%
}}


\newcommand{\ottdruleRedApp}[1]{\ottdrule[#1]{%
}{
 ( \lambda  \mathit{x}  \ottsym{:}  \ottnt{T}  \ldotp  \ottnt{e} )  \, v  \longrightarrow   [  v  /  \mathit{x}  ]  \ottnt{e} }{%
{\ottdrulename{RedApp}}{}%
}}


\newcommand{\ottdruleRedAppEv}[1]{\ottdrule[#1]{%
}{
 ( \varepsilon_{{\mathrm{1}}} \,  ( \lambda  \mathit{x}  \ottsym{:}  \ottnt{T}  \ldotp  \ottnt{e} )  )  \,  ( \varepsilon_{{\mathrm{2}}} \, r )   \longrightarrow  \ottsym{(}  \ottkw{cod} \, \varepsilon_{{\mathrm{2}}}  \ottsym{)} \,  (  [  \ottsym{(}  \ottkw{dom} \, \varepsilon_{{\mathrm{1}}}  \sqcap  \varepsilon_{{\mathrm{2}}}  \ottsym{)} \, r  /  \mathit{x}  ]  \ottnt{e}  ) }{%
{\ottdrulename{RedAppEv}}{}%
}}


\newcommand{\ottdruleRedAppEvFail}[1]{\ottdrule[#1]{%
\ottpremise{\ottkw{dom} \, \varepsilon_{{\mathrm{1}}}  \sqcap  \varepsilon_{{\mathrm{2}}} \, \ottkw{undefined}}%
}{
 ( \varepsilon_{{\mathrm{1}}} \,  ( \lambda  \mathit{x}  \ottsym{:}  \ottnt{T}  \ldotp  \ottnt{e} )  )  \,  ( \varepsilon_{{\mathrm{2}}} \, r )   \longrightarrow  \ottkw{error}}{%
{\ottdrulename{RedAppEvFail}}{}%
}}


\newcommand{\ottdruleRedAppEvPartial}[1]{\ottdrule[#1]{%
}{
 ( \varepsilon \,  ( \lambda  \mathit{x}  \ottsym{:}  \ottnt{T}  \ldotp  \ottnt{e_{{\mathrm{1}}}} )  )  \, r  \longrightarrow  \ottsym{(}  \ottkw{cod} \, \varepsilon  \ottsym{)} \,  (  [  \ottsym{(}  \ottkw{dom} \, \varepsilon  \ottsym{)} \, \ottnt{e_{{\mathrm{2}}}}  /  \mathit{x}  ]  \ottnt{e_{{\mathrm{1}}}}  ) }{%
{\ottdrulename{RedAppEvPartial}}{}%
}}


\newcommand{\ottdruleRedPlus}[1]{\ottdrule[#1]{%
}{
\ottnt{n_{{\mathrm{1}}}}  \ottsym{+}  \ottnt{n_{{\mathrm{2}}}}  \longrightarrow   \ottnt{n_{{\mathrm{1}}}} + \ottnt{n_{{\mathrm{2}}}} }{%
{\ottdrulename{RedPlus}}{}%
}}


\newcommand{\ottdruleRedPlusEvL}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{n_{{\mathrm{1}}}}  \ottsym{+}  v  \longrightarrow  \ottnt{e}}%
}{
\varepsilon \, \ottnt{n_{{\mathrm{1}}}}  \ottsym{+}  v  \longrightarrow  \ottnt{e}}{%
{\ottdrulename{RedPlusEvL}}{}%
}}


\newcommand{\ottdruleRedPlusEvR}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{n_{{\mathrm{1}}}}  \ottsym{+}  \ottnt{n_{{\mathrm{2}}}}  \longrightarrow  \ottnt{e}}%
}{
\ottnt{n_{{\mathrm{1}}}}  \ottsym{+}  \varepsilon \, \ottnt{n_{{\mathrm{2}}}}  \longrightarrow  \ottnt{e}}{%
{\ottdrulename{RedPlusEvR}}{}%
}}


\newcommand{\ottdruleRedEqT}[1]{\ottdrule[#1]{%
}{
\ottnt{n}  \stackrel{?}{=}  \ottnt{n}  \longrightarrow  \ottkw{true}}{%
{\ottdrulename{RedEqT}}{}%
}}


\newcommand{\ottdruleRedEqF}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{n_{{\mathrm{1}}}}  \neq  \ottnt{n_{{\mathrm{2}}}}}%
}{
\ottnt{n_{{\mathrm{1}}}}  \stackrel{?}{=}  \ottnt{n_{{\mathrm{2}}}}  \longrightarrow  \ottkw{false}}{%
{\ottdrulename{RedEqF}}{}%
}}


\newcommand{\ottdruleRedEqEvL}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{n_{{\mathrm{1}}}}  \stackrel{?}{=}  v  \longrightarrow  \ottnt{e}}%
}{
\varepsilon \, \ottnt{n_{{\mathrm{1}}}}  \stackrel{?}{=}  v  \longrightarrow  \ottnt{e}}{%
{\ottdrulename{RedEqEvL}}{}%
}}


\newcommand{\ottdruleRedEqEvR}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{n_{{\mathrm{1}}}}  \stackrel{?}{=}  \ottnt{n_{{\mathrm{2}}}}  \longrightarrow  \ottnt{e}}%
}{
\ottnt{n_{{\mathrm{1}}}}  \stackrel{?}{=}  \varepsilon \, \ottnt{n_{{\mathrm{2}}}}  \longrightarrow  \ottnt{e}}{%
{\ottdrulename{RedEqEvR}}{}%
}}


\newcommand{\ottdruleRedProj}[1]{\ottdrule[#1]{%
\ottpremise{i \, \in \, \ottsym{\{}  \ottsym{1}  \ottsym{,}  \ottsym{2}  \ottsym{\}}}%
}{
 \pi_{ i }   \langle  \ottnt{e_{{\mathrm{1}}}} ,  \ottnt{e_{{\mathrm{2}}}}  \rangle    \longrightarrow  \ottnt{e_{\ottmv{i}}}}{%
{\ottdrulename{RedProj}}{}%
}}


\newcommand{\ottdruleRedProjEv}[1]{\ottdrule[#1]{%
\ottpremise{i \, \in \, \ottsym{\{}  \ottsym{1}  \ottsym{,}  \ottsym{2}  \ottsym{\}}}%
}{
 \pi_{ i }   ( \varepsilon \,  \langle  \ottnt{e_{{\mathrm{1}}}} ,  \ottnt{e_{{\mathrm{2}}}}  \rangle  )    \longrightarrow   \ottkw{Proj}_{ i }  \varepsilon  \, \ottnt{e_{\ottmv{i}}}}{%
{\ottdrulename{RedProjEv}}{}%
}}


\newcommand{\ottdruleRedAscr}[1]{\ottdrule[#1]{%
}{
\varepsilon_{{\mathrm{1}}} \,  ( \varepsilon_{{\mathrm{2}}} \, \ottnt{e} )   \longrightarrow  \ottsym{(}  \varepsilon_{{\mathrm{1}}}  \sqcap  \varepsilon_{{\mathrm{2}}}  \ottsym{)} \, \ottnt{e}}{%
{\ottdrulename{RedAscr}}{}%
}}


\newcommand{\ottdruleRedAscrFail}[1]{\ottdrule[#1]{%
\ottpremise{\varepsilon_{{\mathrm{1}}}  \sqcap  \varepsilon_{{\mathrm{2}}} \, \ottkw{undefined}}%
}{
\varepsilon_{{\mathrm{1}}} \,  ( \varepsilon_{{\mathrm{2}}} \, \ottnt{e} )   \longrightarrow  \ottkw{error}}{%
{\ottdrulename{RedAscrFail}}{}%
}}


\newcommand{\ottdruleRedContext}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{e_{{\mathrm{1}}}}  \longrightarrow  \ottnt{e_{{\mathrm{2}}}}}%
}{
\ottnt{C}  \ottsym{[}  \ottnt{e_{{\mathrm{1}}}}  \ottsym{]}  \longrightarrow  \ottnt{C}  \ottsym{[}  \ottnt{e_{{\mathrm{2}}}}  \ottsym{]}}{%
{\ottdrulename{RedContext}}{}%
}}


\newcommand{\ottdruleRedContextFail}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{e}  \longrightarrow  \ottkw{error}}%
}{
\ottnt{C}  \ottsym{[}  \ottnt{e}  \ottsym{]}  \longrightarrow  \ottnt{C}  \ottsym{[}  \ottkw{error}  \ottsym{]}}{%
{\ottdrulename{RedContextFail}}{}%
}}

\newcommand{\ottdefnRed}[1]{\begin{ottdefnblock}[#1]{$\ottnt{e_{{\mathrm{1}}}}  \longrightarrow  \ottnt{e_{{\mathrm{2}}}}$}{\ottcom{Reduction Relation on terms}}
\ottusedrule{\ottdruleRedIfTrue{}}
\ottusedrule{\ottdruleRedIfFalse{}}
\ottusedrule{\ottdruleRedIfEv{}}
\ottusedrule{\ottdruleRedApp{}}
\ottusedrule{\ottdruleRedAppEv{}}
\ottusedrule{\ottdruleRedAppEvFail{}}
\ottusedrule{\ottdruleRedAppEvPartial{}}
\ottusedrule{\ottdruleRedPlus{}}
\ottusedrule{\ottdruleRedPlusEvL{}}
\ottusedrule{\ottdruleRedPlusEvR{}}
\ottusedrule{\ottdruleRedEqT{}}
\ottusedrule{\ottdruleRedEqF{}}
\ottusedrule{\ottdruleRedEqEvL{}}
\ottusedrule{\ottdruleRedEqEvR{}}
\ottusedrule{\ottdruleRedProj{}}
\ottusedrule{\ottdruleRedProjEv{}}
\ottusedrule{\ottdruleRedAscr{}}
\ottusedrule{\ottdruleRedAscrFail{}}
\ottusedrule{\ottdruleRedContext{}}
\ottusedrule{\ottdruleRedContextFail{}}
\end{ottdefnblock}}


\newcommand{\ottdefnsSemantics}{
\ottdefnRed{}}

% defns Types
%% defn Hastype
\newcommand{\ottdruleHastypeVar}[1]{\ottdrule[#1]{%
\ottpremise{\ottsym{(}  \mathit{x}  \ottsym{:}  \ottnt{T}  \ottsym{)} \, \in \, \Gamma}%
}{
\Gamma  \vdash  \mathit{x}  \ottsym{:}  \ottnt{T}}{%
{\ottdrulename{HastypeVar}}{}%
}}


\newcommand{\ottdruleHastypeBool}[1]{\ottdrule[#1]{%
}{
\Gamma  \vdash  b  \ottsym{:}   \mathsf{Bool} }{%
{\ottdrulename{HastypeBool}}{}%
}}


\newcommand{\ottdruleHastypeNat}[1]{\ottdrule[#1]{%
}{
\Gamma  \vdash  \ottnt{n}  \ottsym{:}   \mathsf{Nat} }{%
{\ottdrulename{HastypeNat}}{}%
}}


\newcommand{\ottdruleHastypePlus}[1]{\ottdrule[#1]{%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{1}}}}  \ottsym{:}   \mathsf{Nat} }%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}   \mathsf{Nat} }%
}{
\Gamma  \vdash  \ottnt{e_{{\mathrm{1}}}}  \ottsym{+}  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}   \mathsf{Nat} }{%
{\ottdrulename{HastypePlus}}{}%
}}


\newcommand{\ottdruleHastypeEq}[1]{\ottdrule[#1]{%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{1}}}}  \ottsym{:}   \mathsf{Nat} }%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}   \mathsf{Nat} }%
}{
\Gamma  \vdash  \ottnt{e_{{\mathrm{1}}}}  \stackrel{?}{=}  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}   \mathsf{Nat} }{%
{\ottdrulename{HastypeEq}}{}%
}}


\newcommand{\ottdruleHastypeLam}[1]{\ottdrule[#1]{%
\ottpremise{\Gamma  \ottsym{,}  \ottsym{(}  \mathit{x}  \ottsym{:}  \ottnt{T_{{\mathrm{1}}}}  \ottsym{)}  \vdash  \ottnt{e}  \ottsym{:}  \ottnt{T_{{\mathrm{2}}}}}%
}{
\Gamma  \vdash  \lambda  \mathit{x}  \ottsym{:}  \ottnt{T_{{\mathrm{1}}}}  \ldotp  \ottnt{e}  \ottsym{:}   \ottnt{T_{{\mathrm{1}}}} \to \ottnt{T_{{\mathrm{2}}}} }{%
{\ottdrulename{HastypeLam}}{}%
}}


\newcommand{\ottdruleHastypeApp}[1]{\ottdrule[#1]{%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{1}}}}  \ottsym{:}   \ottnt{T_{{\mathrm{1}}}} \to \ottnt{T_{{\mathrm{2}}}} }%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}  \ottnt{T_{{\mathrm{1}}}}}%
}{
\Gamma  \vdash  \ottnt{e_{{\mathrm{1}}}} \, \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}  \ottnt{T_{{\mathrm{2}}}}}{%
{\ottdrulename{HastypeApp}}{}%
}}


\newcommand{\ottdruleHastypeIf}[1]{\ottdrule[#1]{%
\ottpremise{\Gamma  \vdash  \ottnt{e}  \ottsym{:}   \mathsf{Bool} }%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{1}}}}  \ottsym{:}  \ottnt{T}}%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}  \ottnt{T}}%
}{
\Gamma  \vdash  \ottkw{if} \, \ottnt{e} \, \ottkw{then} \, \ottnt{e_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}  \ottnt{T}}{%
{\ottdrulename{HastypeIf}}{}%
}}


\newcommand{\ottdruleHastypePair}[1]{\ottdrule[#1]{%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{1}}}}  \ottsym{:}  \ottnt{T_{{\mathrm{1}}}}}%
\ottpremise{\Gamma  \vdash  \ottnt{e_{{\mathrm{2}}}}  \ottsym{:}  \ottnt{T_{{\mathrm{2}}}}}%
}{
\Gamma  \vdash   \langle  \ottnt{e_{{\mathrm{1}}}} ,  \ottnt{e_{{\mathrm{2}}}}  \rangle   \ottsym{:}   \ottnt{T_{{\mathrm{1}}}} \times \ottnt{T_{{\mathrm{2}}}} }{%
{\ottdrulename{HastypePair}}{}%
}}


\newcommand{\ottdruleHastypeProj}[1]{\ottdrule[#1]{%
\ottpremise{\Gamma  \vdash  \ottnt{e}  \ottsym{:}   \ottnt{T_{{\mathrm{1}}}} \times \ottnt{T_{{\mathrm{2}}}} }%
\ottpremise{i \, \in \, \ottsym{\{}  \ottsym{1}  \ottsym{,}  \ottsym{2}  \ottsym{\}}}%
}{
\Gamma  \vdash   \mathtt{ p } _{ i }  \, \ottnt{e}  \ottsym{:}  \ottnt{T}}{%
{\ottdrulename{HastypeProj}}{}%
}}


\newcommand{\ottdruleHastypeAscr}[1]{\ottdrule[#1]{%
\ottpremise{\Gamma  \vdash  \ottnt{e}  \ottsym{:}  \ottnt{T_{{\mathrm{2}}}}}%
\ottpremise{\varepsilon  \vdash  \ottnt{T_{{\mathrm{1}}}}  \cong  \ottnt{T_{{\mathrm{2}}}}}%
}{
\Gamma  \vdash  \varepsilon \, \ottnt{e}  \ottsym{:}  \ottnt{T_{{\mathrm{1}}}}}{%
{\ottdrulename{HastypeAscr}}{}%
}}

\newcommand{\ottdefnHastype}[1]{\begin{ottdefnblock}[#1]{$\Gamma  \vdash  \ottnt{e}  \ottsym{:}  \ottnt{T}$}{\ottcom{Typability relation}}
\ottusedrule{\ottdruleHastypeVar{}}
\ottusedrule{\ottdruleHastypeBool{}}
\ottusedrule{\ottdruleHastypeNat{}}
\ottusedrule{\ottdruleHastypePlus{}}
\ottusedrule{\ottdruleHastypeEq{}}
\ottusedrule{\ottdruleHastypeLam{}}
\ottusedrule{\ottdruleHastypeApp{}}
\ottusedrule{\ottdruleHastypeIf{}}
\ottusedrule{\ottdruleHastypePair{}}
\ottusedrule{\ottdruleHastypeProj{}}
\ottusedrule{\ottdruleHastypeAscr{}}
\end{ottdefnblock}}

%% defn Consistent
\newcommand{\ottdruleConsistentEv}[1]{\ottdrule[#1]{%
\ottpremise{ \ottnt{T_{{\mathrm{3}}}}  \sqcap  \ottnt{T_{{\mathrm{1}}}}  =  \ottnt{T_{{\mathrm{3}}}} }%
\ottpremise{ \ottnt{T_{{\mathrm{3}}}}  \sqcap  \ottnt{T_{{\mathrm{2}}}}  =  \ottnt{T_{{\mathrm{3}}}} }%
}{
 \{  \ottnt{T_{{\mathrm{3}}}}  \}   \vdash  \ottnt{T_{{\mathrm{1}}}}  \cong  \ottnt{T_{{\mathrm{2}}}}}{%
{\ottdrulename{ConsistentEv}}{}%
}}

\newcommand{\ottdefnConsistent}[1]{\begin{ottdefnblock}[#1]{$\varepsilon  \vdash  \ottnt{T_{{\mathrm{1}}}}  \cong  \ottnt{T_{{\mathrm{2}}}}$}{\ottcom{Type Consistency relative to Evidence}}
\ottusedrule{\ottdruleConsistentEv{}}
\end{ottdefnblock}}

%% defn Meet
\newcommand{\ottdruleMeetDynL}[1]{\ottdrule[#1]{%
}{
 \ottsym{\mbox{?}}  \sqcap  \ottnt{T}  =  \ottnt{T} }{%
{\ottdrulename{MeetDynL}}{}%
}}


\newcommand{\ottdruleMeetDynR}[1]{\ottdrule[#1]{%
}{
 \ottnt{T}  \sqcap  \ottsym{\mbox{?}}  =  \ottnt{T} }{%
{\ottdrulename{MeetDynR}}{}%
}}


\newcommand{\ottdruleMeetRefl}[1]{\ottdrule[#1]{%
}{
 \ottnt{T}  \sqcap  \ottnt{T}  =  \ottnt{T} }{%
{\ottdrulename{MeetRefl}}{}%
}}


\newcommand{\ottdruleMeetFun}[1]{\ottdrule[#1]{%
\ottpremise{ \ottnt{T_{{\mathrm{1}}}}  \sqcap  \ottnt{T'_{{\mathrm{1}}}}  =  \ottnt{T''_{{\mathrm{1}}}} }%
\ottpremise{ \ottnt{T_{{\mathrm{2}}}}  \sqcap  \ottnt{T'_{{\mathrm{2}}}}  =  \ottnt{T''_{{\mathrm{2}}}} }%
}{
  \ottnt{T_{{\mathrm{1}}}} \to \ottnt{T_{{\mathrm{2}}}}   \sqcap   \ottnt{T'_{{\mathrm{1}}}} \to \ottnt{T'_{{\mathrm{2}}}}   =   \ottnt{T''_{{\mathrm{1}}}} \to \ottnt{T''_{{\mathrm{2}}}}  }{%
{\ottdrulename{MeetFun}}{}%
}}


\newcommand{\ottdruleMeetProd}[1]{\ottdrule[#1]{%
\ottpremise{ \ottnt{T_{{\mathrm{1}}}}  \sqcap  \ottnt{T'_{{\mathrm{1}}}}  =  \ottnt{T''_{{\mathrm{1}}}} }%
\ottpremise{ \ottnt{T_{{\mathrm{2}}}}  \sqcap  \ottnt{T'_{{\mathrm{2}}}}  =  \ottnt{T''_{{\mathrm{2}}}} }%
}{
  \ottnt{T_{{\mathrm{1}}}} \times \ottnt{T_{{\mathrm{2}}}}   \sqcap   \ottnt{T'_{{\mathrm{1}}}} \times \ottnt{T'_{{\mathrm{2}}}}   =   \ottnt{T''_{{\mathrm{1}}}} \times \ottnt{T''_{{\mathrm{2}}}}  }{%
{\ottdrulename{MeetProd}}{}%
}}

\newcommand{\ottdefnMeet}[1]{\begin{ottdefnblock}[#1]{$ \ottnt{T_{{\mathrm{1}}}}  \sqcap  \ottnt{T_{{\mathrm{2}}}}  =  \ottnt{T_{{\mathrm{3}}}} $}{\ottcom{Precision Meet}}
\ottusedrule{\ottdruleMeetDynL{}}
\ottusedrule{\ottdruleMeetDynR{}}
\ottusedrule{\ottdruleMeetRefl{}}
\ottusedrule{\ottdruleMeetFun{}}
\ottusedrule{\ottdruleMeetProd{}}
\end{ottdefnblock}}

%% defn ValTransform
\newcommand{\ottdruleValTransformBool}[1]{\ottdrule[#1]{%
}{
\llbracket  b  \rrbracket  =   \langle   \mathtt{ DYN }  ,  b \rangle }{%
{\ottdrulename{ValTransformBool}}{}%
}}


\newcommand{\ottdruleValTransformNum}[1]{\ottdrule[#1]{%
}{
\llbracket  \ottnt{n}  \rrbracket  =   \langle   \mathtt{ DYN }  ,  \ottnt{n} \rangle }{%
{\ottdrulename{ValTransformNum}}{}%
}}


\newcommand{\ottdruleValTransformFun}[1]{\ottdrule[#1]{%
\ottpremise{\llbracket  \ottnt{e}  \rrbracket  \mathit{c}  =  \ottnt{t}}%
}{
\llbracket  \lambda  \mathit{x}  \ottsym{:}  \ottnt{T}  \ldotp  \ottnt{e}  \rrbracket  =   \langle   \mathtt{ DYN }  ,  \lambda  \mathit{x} \, \mathit{c}  \ldotp  \ottnt{t} \rangle }{%
{\ottdrulename{ValTransformFun}}{}%
}}


\newcommand{\ottdruleValTransformPair}[1]{\ottdrule[#1]{%
}{
\llbracket   \langle  v_{{\mathrm{1}}} ,  v_{{\mathrm{2}}}  \rangle   \rrbracket  =   \langle   \mathtt{ DYN }  ,   \langle  \llbracket  v_{{\mathrm{1}}}  \rrbracket ,  \llbracket  v_{{\mathrm{2}}}  \rrbracket \rangle  \rangle }{%
{\ottdrulename{ValTransformPair}}{}%
}}


\newcommand{\ottdruleValTransformEv}[1]{\ottdrule[#1]{%
\ottpremise{\llbracket  r  \rrbracket  =   \langle   \mathtt{ DYN }  ,  \ottnt{u} \rangle }%
}{
\llbracket  \varepsilon \, r  \rrbracket  =   \langle  \llbracket  \varepsilon  \rrbracket ,  \ottnt{u} \rangle }{%
{\ottdrulename{ValTransformEv}}{}%
}}

\newcommand{\ottdefnValTransform}[1]{\begin{ottdefnblock}[#1]{$\llbracket  v  \rrbracket  =  \ottnt{u}$}{\ottcom{CPS Translation of Closed Values}}
\ottusedrule{\ottdruleValTransformBool{}}
\ottusedrule{\ottdruleValTransformNum{}}
\ottusedrule{\ottdruleValTransformFun{}}
\ottusedrule{\ottdruleValTransformPair{}}
\ottusedrule{\ottdruleValTransformEv{}}
\end{ottdefnblock}}

%% defn Transform
\newcommand{\ottdruleTransformVar}[1]{\ottdrule[#1]{%
}{
\llbracket  \mathit{x}  \rrbracket  \ottnt{k}  =   \ottnt{k} ( \mathit{x} ) }{%
{\ottdrulename{TransformVar}}{}%
}}


\newcommand{\ottdruleTransformBool}[1]{\ottdrule[#1]{%
}{
\llbracket  b  \rrbracket  \ottnt{k}  =   \ottnt{k} (  \langle   \mathtt{ DYN }  ,  b \rangle  ) }{%
{\ottdrulename{TransformBool}}{}%
}}


\newcommand{\ottdruleTransformNum}[1]{\ottdrule[#1]{%
}{
\llbracket  \ottnt{n}  \rrbracket  \ottnt{k}  =   \ottnt{k} (  \langle   \mathtt{ DYN }  ,  \ottnt{n} \rangle  ) }{%
{\ottdrulename{TransformNum}}{}%
}}


\newcommand{\ottdruleTransformFun}[1]{\ottdrule[#1]{%
\ottpremise{\llbracket  \ottnt{e}  \rrbracket  \mathit{c}  =  \ottnt{t}}%
}{
\llbracket   ( \lambda  \mathit{x}  \ottsym{:}  \ottnt{T}  \ldotp  \ottnt{e} )   \rrbracket  \ottnt{k}  =   \ottnt{k} (  \langle   \mathtt{ DYN }  ,  \lambda  \mathit{x} \, \mathit{c}  \ldotp  \ottnt{t} \rangle  ) }{%
{\ottdrulename{TransformFun}}{}%
}}


\newcommand{\ottdruleTransformApp}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{k_{{\mathrm{1}}}}  \ottsym{:=}  \ottsym{(}  \lambda  \mathit{x_{{\mathrm{2}}}}  \ldotp  \ottkw{let} \, \mathit{y_{{\mathrm{1}}}}  \ottsym{:=}  \pi_1  \mathit{x_{{\mathrm{1}}}} \, \ottkw{in} \, \ottkw{let} \, \mathit{z_{{\mathrm{1}}}}  \ottsym{:=}  \pi_2  \mathit{x_{{\mathrm{1}}}} \, \ottkw{in} \, \ottkw{let} \, \mathit{y_{{\mathrm{2}}}}  \ottsym{:=}  \pi_1  \mathit{x_{{\mathrm{2}}}} \, \ottkw{in} \, \ottkw{let} \, \mathit{z_{{\mathrm{2}}}}  \ottsym{:=}  \pi_2  \mathit{x_{{\mathrm{2}}}} \, \ottkw{in} \, \ottnt{t_{{\mathrm{1}}}}  \ottsym{)}}%
\ottpremise{\ottnt{t_{{\mathrm{1}}}}  \ottsym{:=}    \mathtt{DOM }  ( \mathit{y_{{\mathrm{1}}}}  \ottsym{,}  \lambda  \mathit{y'_{{\mathrm{1}}}}  \ldotp    \mathtt{COD }  ( \mathit{y_{{\mathrm{1}}}}  \ottsym{,}  \lambda  \mathit{y''_{{\mathrm{1}}}}  \ldotp    \mathtt{MEET }  ( \mathit{y'_{{\mathrm{1}}}}  \ottsym{,}  \mathit{y_{{\mathrm{2}}}}  \ottsym{,}  \ottsym{(}  \lambda  \mathit{y_{{\mathrm{3}}}}  \ldotp   \mathit{z_{{\mathrm{1}}}} (  \langle  \mathit{y_{{\mathrm{3}}}} ,  \mathit{z_{{\mathrm{2}}}} \rangle   \ottsym{,}  \ottsym{(}  \lambda  \mathit{z_{{\mathrm{3}}}}  \ldotp  \ottnt{t_{{\mathrm{2}}}}  \ottsym{)} )   \ottsym{)} )  )  ) }%
\ottpremise{\ottnt{t_{{\mathrm{2}}}}  \ottsym{:=}  \ottkw{let} \, \mathit{z'_{{\mathrm{3}}}}  \ottsym{:=}  \pi_1  \mathit{z_{{\mathrm{3}}}} \, \ottkw{in} \, \ottkw{let} \, \mathit{z''_{{\mathrm{3}}}}  \ottsym{:=}  \pi_2  \mathit{z_{{\mathrm{3}}}} \, \ottkw{in} \,   \mathtt{MEET }  ( \mathit{y''_{{\mathrm{1}}}}  \ottsym{,}  \mathit{z'_{{\mathrm{3}}}}  \ottsym{,}  \ottsym{(}  \lambda  \mathit{z_{{\mathrm{4}}}}  \ldotp   \ottnt{k} (  \langle  \mathit{z_{{\mathrm{4}}}} ,  \mathit{z''_{{\mathrm{3}}}} \rangle  )   \ottsym{)} ) }%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{2}}}}  \rrbracket  \ottnt{k_{{\mathrm{1}}}}  =  \ottnt{t'}}%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{1}}}}  \rrbracket  \ottsym{(}  \lambda  \mathit{x_{{\mathrm{1}}}}  \ldotp  \ottnt{t'}  \ottsym{)}  =  \ottnt{t}}%
}{
\llbracket  \ottnt{e_{{\mathrm{1}}}} \, \ottnt{e_{{\mathrm{2}}}}  \rrbracket  \ottnt{k}  =  \ottnt{t}}{%
{\ottdrulename{TransformApp}}{}%
}}


\newcommand{\ottdruleTransformPlus}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{k_{{\mathrm{1}}}}  \ottsym{:=}  \ottsym{(}  \lambda  \mathit{x_{{\mathrm{2}}}}  \ldotp  \ottkw{let} \, \mathit{z_{{\mathrm{1}}}}  \ottsym{:=}  \pi_2  \mathit{x_{{\mathrm{1}}}} \, \ottkw{in} \, \ottkw{let} \, \mathit{z_{{\mathrm{2}}}}  \ottsym{:=}  \pi_2  \mathit{x_{{\mathrm{2}}}} \, \ottkw{in} \, \ottkw{let} \, \mathit{z_{{\mathrm{3}}}}  \ottsym{:=}  \mathit{z_{{\mathrm{1}}}}  \ottsym{+}  \mathit{z_{{\mathrm{2}}}} \, \ottkw{in} \,  \ottnt{k} ( \mathit{z_{{\mathrm{3}}}} )   \ottsym{)}}%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{2}}}}  \rrbracket  \ottnt{k_{{\mathrm{1}}}}  =  \ottnt{t'}}%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{1}}}}  \rrbracket  \ottsym{(}  \lambda  \mathit{x_{{\mathrm{1}}}}  \ldotp  \ottnt{t'}  \ottsym{)}  =  \ottnt{t}}%
}{
\llbracket  \ottnt{e_{{\mathrm{1}}}}  \ottsym{+}  \ottnt{e_{{\mathrm{2}}}}  \rrbracket  \ottnt{k}  =  \ottnt{t}}{%
{\ottdrulename{TransformPlus}}{}%
}}


\newcommand{\ottdruleTransformEq}[1]{\ottdrule[#1]{%
\ottpremise{\ottnt{k_{{\mathrm{1}}}}  \ottsym{:=}  \ottsym{(}  \lambda  \mathit{x_{{\mathrm{2}}}}  \ldotp  \ottkw{let} \, \mathit{z_{{\mathrm{1}}}}  \ottsym{:=}  \pi_2  \mathit{x_{{\mathrm{1}}}} \, \ottkw{in} \, \ottkw{let} \, \mathit{z_{{\mathrm{2}}}}  \ottsym{:=}  \pi_2  \mathit{x_{{\mathrm{2}}}} \, \ottkw{in} \, \ottkw{let} \, \mathit{z_{{\mathrm{3}}}}  \ottsym{:=}  \mathit{z_{{\mathrm{1}}}}  \stackrel{?}{=}  \mathit{z_{{\mathrm{2}}}} \, \ottkw{in} \,  \ottnt{k} ( \mathit{z_{{\mathrm{3}}}} )   \ottsym{)}}%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{2}}}}  \rrbracket  \ottnt{k_{{\mathrm{1}}}}  =  \ottnt{t'}}%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{1}}}}  \rrbracket  \ottsym{(}  \lambda  \mathit{x_{{\mathrm{1}}}}  \ldotp  \ottnt{t'}  \ottsym{)}  =  \ottnt{t}}%
}{
\llbracket  \ottnt{e_{{\mathrm{1}}}}  \ottsym{+}  \ottnt{e_{{\mathrm{2}}}}  \rrbracket  \ottnt{k}  =  \ottnt{t}}{%
{\ottdrulename{TransformEq}}{}%
}}


\newcommand{\ottdruleTransformPair}[1]{\ottdrule[#1]{%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{2}}}}  \rrbracket  \ottsym{(}  \lambda  \mathit{x_{{\mathrm{2}}}}  \ldotp   \ottnt{k} (  \langle   \mathtt{ DYN }  ,   \langle  \mathit{x_{{\mathrm{1}}}} ,  \mathit{x_{{\mathrm{2}}}} \rangle  \rangle  )   \ottsym{)}  =  \ottnt{t'}}%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{1}}}}  \rrbracket  \ottsym{(}  \lambda  \mathit{x_{{\mathrm{1}}}}  \ldotp  \ottnt{t'}  \ottsym{)}  =  \ottnt{t}}%
}{
\llbracket   \langle  \ottnt{e_{{\mathrm{1}}}} ,  \ottnt{e_{{\mathrm{2}}}}  \rangle   \rrbracket  \ottnt{k}  =  \ottnt{t}}{%
{\ottdrulename{TransformPair}}{}%
}}


\newcommand{\ottdruleTransformIf}[1]{\ottdrule[#1]{%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{1}}}}  \rrbracket  \ottnt{k}  =  \ottnt{t_{{\mathrm{1}}}}}%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{2}}}}  \rrbracket  \ottnt{k}  =  \ottnt{t_{{\mathrm{2}}}}}%
\ottpremise{\llbracket  \ottnt{e_{{\mathrm{0}}}}  \rrbracket  \ottsym{(}  \lambda  \mathit{x_{{\mathrm{0}}}}  \ldotp  \ottkw{let} \, \mathit{x}  \ottsym{:=}  \pi_2  \mathit{x_{{\mathrm{0}}}} \, \ottkw{in} \,  \ottkw{ if }\  \mathit{x} \ \ottkw{ then }\  \ottnt{t_{{\mathrm{1}}}} \ \ottkw{ else }\  \ottnt{t_{{\mathrm{2}}}}   \ottsym{)}  =  \ottnt{t}}%
}{
\llbracket  \ottkw{if} \, \ottnt{e_{{\mathrm{0}}}} \, \ottkw{then} \, \ottnt{e_{{\mathrm{1}}}} \, \ottkw{else} \, \ottnt{e_{{\mathrm{2}}}}  \rrbracket  \ottnt{k}  =  \ottnt{t}}{%
{\ottdrulename{TransformIf}}{}%
}}


\newcommand{\ottdruleTransformProj}[1]{\ottdrule[#1]{%
\ottpremise{\llbracket  \ottnt{e}  \rrbracket  \ottsym{(}  \lambda  \mathit{x}  \ldotp  \ottkw{let} \, \mathit{x'}  \ottsym{:=} \, \pi \, \ottsym{@}  i \, \mathit{x} \, \ottkw{in} \,  \ottnt{k} ( \mathit{x'} )   \ottsym{)}  =  \ottnt{t}}%
}{
\llbracket   \pi_{ i }  \ottnt{e}   \rrbracket  \ottnt{k}  =  \ottnt{t}}{%
{\ottdrulename{TransformProj}}{}%
}}


\newcommand{\ottdruleTransformEv}[1]{\ottdrule[#1]{%
\ottpremise{\llbracket  \ottnt{e}  \rrbracket  \ottsym{(}  \lambda  \mathit{x}  \ldotp  \ottkw{let} \, \mathit{x_{{\mathrm{1}}}}  \ottsym{:=}  \pi_1  \mathit{x} \, \ottkw{in} \, \ottkw{let} \, \mathit{x_{{\mathrm{2}}}}  \ottsym{:=}  \pi_2  \mathit{x} \, \ottkw{in} \,   \mathtt{MEET }  ( \llbracket  \varepsilon  \rrbracket  \ottsym{,}  \mathit{x_{{\mathrm{1}}}}  \ottsym{,}  \ottsym{(}  \lambda  \mathit{y}  \ldotp   \ottnt{k} (  \langle  \mathit{y} ,  \mathit{x_{{\mathrm{2}}}} \rangle  )   \ottsym{)} )   \ottsym{)}  =  \ottnt{t}}%
}{
\llbracket  \varepsilon \, \ottnt{e}  \rrbracket  \ottnt{k}  =  \ottnt{t}}{%
{\ottdrulename{TransformEv}}{}%
}}


\newcommand{\ottdruleTransformErr}[1]{\ottdrule[#1]{%
}{
\llbracket  \ottkw{error}  \rrbracket  \ottnt{k}  =  \ottkw{error}}{%
{\ottdrulename{TransformErr}}{}%
}}

\newcommand{\ottdefnTransform}[1]{\begin{ottdefnblock}[#1]{$\llbracket  \ottnt{e}  \rrbracket  \ottnt{k}  =  \ottnt{t}$}{\ottcom{CPS Translation of Expressions}}
\ottusedrule{\ottdruleTransformVar{}}
\ottusedrule{\ottdruleTransformBool{}}
\ottusedrule{\ottdruleTransformNum{}}
\ottusedrule{\ottdruleTransformFun{}}
\ottusedrule{\ottdruleTransformApp{}}
\ottusedrule{\ottdruleTransformPlus{}}
\ottusedrule{\ottdruleTransformEq{}}
\ottusedrule{\ottdruleTransformPair{}}
\ottusedrule{\ottdruleTransformIf{}}
\ottusedrule{\ottdruleTransformProj{}}
\ottusedrule{\ottdruleTransformEv{}}
\ottusedrule{\ottdruleTransformErr{}}
\end{ottdefnblock}}

%% defn EvTransform
\newcommand{\ottdruleEvTransformBool}[1]{\ottdrule[#1]{%
}{
\llbracket   \{   \mathsf{Bool}   \}   \rrbracket  =   \langle   \mathtt{BOOL }  ,  \ottsym{0} \rangle }{%
{\ottdrulename{EvTransformBool}}{}%
}}


\newcommand{\ottdruleEvTransformNat}[1]{\ottdrule[#1]{%
}{
\llbracket   \{   \mathsf{Nat}   \}   \rrbracket  =   \langle   \mathtt{NAT }  ,  \ottsym{0} \rangle }{%
{\ottdrulename{EvTransformNat}}{}%
}}


\newcommand{\ottdruleEvTransformDyn}[1]{\ottdrule[#1]{%
}{
\llbracket   \{  \ottsym{\mbox{?}}  \}   \rrbracket  =   \langle   \mathtt{ DYN }  ,  \ottsym{0} \rangle }{%
{\ottdrulename{EvTransformDyn}}{}%
}}


\newcommand{\ottdruleEvTransformArr}[1]{\ottdrule[#1]{%
}{
\llbracket   \{   \ottnt{T_{{\mathrm{1}}}} \to \ottnt{T_{{\mathrm{2}}}}   \}   \rrbracket  =   \langle   \mathtt{ARROW }  ,   \langle  \llbracket   \{  \ottnt{T_{{\mathrm{1}}}}  \}   \rrbracket ,  \llbracket   \{  \ottnt{T_{{\mathrm{2}}}}  \}   \rrbracket \rangle  \rangle }{%
{\ottdrulename{EvTransformArr}}{}%
}}


\newcommand{\ottdruleEvTransformProd}[1]{\ottdrule[#1]{%
}{
\llbracket   \{   \ottnt{T_{{\mathrm{1}}}} \to \ottnt{T_{{\mathrm{2}}}}   \}   \rrbracket  =   \langle   \mathtt{PRODUCT }  ,   \langle  \llbracket   \{  \ottnt{T_{{\mathrm{1}}}}  \}   \rrbracket ,  \llbracket   \{  \ottnt{T_{{\mathrm{2}}}}  \}   \rrbracket \rangle  \rangle }{%
{\ottdrulename{EvTransformProd}}{}%
}}

\newcommand{\ottdefnEvTransform}[1]{\begin{ottdefnblock}[#1]{$\llbracket  \varepsilon  \rrbracket  =  \ottnt{u}$}{\ottcom{CPS Representation of Runtime Evidence}}
\ottusedrule{\ottdruleEvTransformBool{}}
\ottusedrule{\ottdruleEvTransformNat{}}
\ottusedrule{\ottdruleEvTransformDyn{}}
\ottusedrule{\ottdruleEvTransformArr{}}
\ottusedrule{\ottdruleEvTransformProd{}}
\end{ottdefnblock}}

%% defn KStep

\newcommand{\ottdefnKStep}[1]{\begin{ottdefnblock}[#1]{$\ottnt{t_{{\mathrm{1}}}}  {\longrightarrow^{*} }  \ottnt{t_{{\mathrm{2}}}}$}{}
\end{ottdefnblock}}


\newcommand{\ottdefnsTypes}{
\ottdefnHastype{}\ottdefnConsistent{}\ottdefnMeet{}\ottdefnValTransform{}\ottdefnTransform{}\ottdefnEvTransform{}\ottdefnKStep{}}

\newcommand{\ottdefnss}{
\ottdefnsSemantics
\ottdefnsTypes
}

\newcommand{\ottall}{\ottmetavars\\[0pt]
\ottgrammar\\[5.0mm]





\ottdefnss

\ottdefnss}

