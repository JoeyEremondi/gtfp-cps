% !Ott debug
% !Ott output ./GTFL.tex
% !Ott binary /home/joey/GitHub/ott/bin/ott 

embed {{tex-wrap-pre
\documentclass[11pt]{article}
\usepackage{amsmath,amssymb}
\usepackage{supertabular}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{pdflscape}
\usepackage{alltt}%hack
\geometry{a4paper,dvips,twoside,left=22.5mm,right=22.5mm,top=20mm,bottom=30mm}
\usepackage{color}
\usepackage{mathpartir}
}}

% \let\olddefs\ottdefnss
% \renewcommand{\ottdefnss}{
% \begin{figure}
% \olddefs
% \label{fig:relations}
% \caption{Reduction and Conversion Relations on Terms}
% \end{figure}
% }

embed {{tex 




\ottdefnss
}}


metavar x, y, z, c  ::= {{com Symbols from some infinite set}}
  {{ tex \mathit{[[x]]} }}  {{ texvar \mathsf{[[x]]} }} {{ lex alphanum }}

indexvar i  ::= {{com Indices (ott artifact, please ignore)}}
  {{ tex [[i]] }}  {{ texvar [[i]] }} {{ lex num }}


grammar

n  :: Integer ::= {{com Integers }}
  |  n1 :+: n2  :: M :: Plus {{tex [[n1]]+[[n2]]}} %TODO color
  | DYN :: M :: Dyn
  | BOOL :: M :: Bool
  | NAT :: M :: Nat
  | ARR :: M :: Arr
  | PROD :: M :: Prod

b {{tex b}} :: Boolean ::= {{ com Booleans }}
  | true :: :: True
  | false :: :: False


e :: e ::= 
  | x :: :: Var {{com Variables}}
  | b :: :: Bool {{com Booleans }}
  | n :: :: Nat {{com Number}}
  | \ x : T . e :: :: Lam {{com Functions }} {{ tex \lambda [[x]] \ldotp [[e]]}}
  | e1 $ e2 :: :: App {{com Function Application}} {{tex [[e1]]\ [[e2]]}}
  | e1 + e2 :: :: Plus
  | e1 == e2 :: :: Eq
  | if e1 then e2 else e3 :: :: If {{com Conditionals}} {{tex \ottkw{if}\ [[e1]]\ \ottkw{then}\ [[e2]]\ \ottkw{else}\ [[e3]]}}
  | ( e1 , e2 ) :: :: Pair
  | pi1 e :: :: Proj1 {{tex \pi_1 [[e]]}}
  | pi2 e :: :: Proj2 {{tex \pi_2 [[e]]}}
  | pi @ i e :: M :: Proji {{tex \pi_{[[i]]} [[e]] }}
  | e @ i :: M :: Expri {{tex [[e]]_{[[i]]} }}
  | ep e :: :: Ascr
  | error :: :: Err
  | ( e ) :: M :: Parens {{tex ([[e]]) }} 
  | [ x |=> e1 ] e2 :: M :: Subst {{tex  [ [[e1]] / [[x]] ] [[e2]] }}
  | C [ e ] :: :: Context 
  | eval ( e ) :: M :: Eval
  | 120 :: M :: Num120
  | 5 :: M :: Num5
  | 4 :: M :: Num4
  | 3 :: M :: Num3
  | 2 :: M :: Num2
  | 0 :: M :: Num0
  | 1 :: M :: Num1
  | e e1 ... ei :: M :: MApp
  | ( e1 , .... ,  ei ) :: M :: PairMany


O :: Observable ::= {{com Observable values: booleans or well-formed natural numbers}}
  | b :: :: Bool
  | n :: :: Nat

r {{tex r}} :: Raw ::= {{com Raw Irreducable (not necessarily observable) values}}
  | b :: :: Bool
  | n :: :: Nat
  | \ x : T . e :: :: Lam {{com Functions }} {{ tex \lambda [[x]] \ldotp [[e]]}}
  | ( v1 , v2 ) :: :: Pair
  | ( r1 , .... ,  ri ) :: M :: PairMany

v {{tex v}} :: Irr ::= {{com Irreducable (not necessarily observable) values}}
  | ep r :: :: Ascr
  | b :: :: Bool 
  | n :: :: Nat
  | \ x : T . e :: :: Lam {{com Functions }} {{ tex \lambda [[x]] \ldotp [[e]]}}
  | ( v1 , v2 ) :: :: Pair
  | ( v1 , .... ,  vi ) :: M :: PairMany

ep {{tex \varepsilon}} :: Evidence ::= 
  | << T >> :: :: Ev {{tex \langle [[T]] \rangle}}
  | ep1 /\ ep2 :: M :: Meet
  | dom ep :: M :: Dom
  | cod ep :: M :: Cod
  | Proj1 ep :: M :: Left
  | Proj2 ep :: M :: Right
  | Proj @ i ep :: M :: Proji

T :: Type ::= {{com Types}}
  | Nat :: :: Nat {{tex \mathsf{Nat} }}
  | Bool :: :: Bool {{tex \mathsf{Bool} }}
  | T1 -> T2 :: :: Arrow {{tex [[T1]]\to[[T2]]}}
  | T1 * T2 :: :: PRoduct {{ tex [[T1]]\times[[T2]]}}
  | ? :: :: Unknown 
  % | dom T :: M :: Dom
  % | cod T :: M :: Cod
  % | left T :: M :: Left 
  % | right T :: M :: Right   
  | ( T ) :: M :: Parens {{tex ([[T]])}}
  | [ T ] :: M :: Implicit {{ tex [[T]] }}

Gamma {{tex \Gamma}} :: Gamma ::= {{com Environments}}
  | empty :: :: Empty {{tex \cdot}}
  | Gamma , ( x : T ) :: :: Cons 

C :: C ::=                               {{ com evaluation context }}
  | __ e         ::  :: AppL                   
  | v __         ::  :: AppR                  
  | ( __ , e ) :: ::  PairL
  | ( v , __ ) :: :: PairR
  | ( pi1 __ ) :: :: Proj1
  | ( pi2 __ ) :: :: Proj2
  | ep __ :: :: Ascr
  | __ + e1 :: :: PlusL
  | v + __ :: :: PlusR
  | __ == e1 :: :: EqL
  | v == __ :: :: EqR
  | if __ then e1 else e2 :: :: If


u , k :: CPSValue ::= 
  | x :: :: Var
  | n :: :: Nat
  | b :: :: Bool
  |  \ x1 ... xi . t  :: :: Fun
  | ( u1 , u2 ) :: :: Pair
  | ( u ) :: M :: Parens
  | MEET :: M :: MeetFun
  | DOM ::  M :: DomFun
  | COD :: M :: CodFun
  | PROD1 :: M :: Prod1
  | PROD2 :: M :: Prod2
  | PROD @ i :: M :: Prodi

d :: CPSDecl ::=
  | x = u :: :: Def
  | x = pi1 u :: :: Proj1
  | x = pi2 u :: :: Proj2
  | x = u1 + u2 :: :: Plus
  | x = u1 == u2 :: :: Eq
  | x = pi @ i u :: M :: Proji


t :: CPS ::= 
  | v :: :: Value 
  | let d in t :: :: Let
  | u' [ u1 , ... , ui ] :: :: App
  | if u t1 t2 :: :: If
  | halt [ u ] :: :: ReturnHalt
  | error :: :: ErrorHalt
  | ( t ) :: M :: Parens


terminals :: 'terminals_' ::=
  | --> :: :: StepsTo {{tex \longrightarrow}}
  | -->* :: :: StepsToStar {{tex {\longrightarrow^{*} } }}
  | =/= :: :: Neq {{tex \neq }}
  | |- :: :: Turnstile {{tex \vdash}}
  | pi :: :: Pi {{tex \pi}}
  | ~=~ :: :: Cong {{tex \cong}}
  | /\ :: :: Meet {{tex \sqcap}}
  | dom :: :: Dom {{tex \ottkw{dom} }}
  | cod :: :: Cod {{tex \ottkw{cod} }}
  | Proj1 :: :: Proj1 {{tex \ottkw{Proj}_1 }}
  | Proj2 :: :: Proj2 {{tex \ottkw{Proj}_2 }}
  | elem :: :: Elem {{tex \in}}

formula :: 'formula_' ::=
    % | formula \\\\ :: :: lbh {{ tex [[formula]] \ottlinebreakhack }}
      | judgement           ::   :: judgement
      | e1 =/= e2 :: :: Neq
      | ( x : T ) elem Gamma :: :: Lookup
      | ep undefined :: :: Undef
      | T1 ==== T2 :: :: TypeEq
      | i elem { 1 , 2 } :: :: Index
      | c fresh :: :: Fresh
      | k := k' :: :: Assign
      | t := t' :: :: Assignt


contextrules
  C _:: e :: e

subrules 
  O <:: e
  v <:: e
  r <:: v

  




defns
Semantics :: '' ::=

defn
e1 --> e2 :: :: Red :: Red {{com Reduction Relation on terms}} 
by 

----------------------------------------- :: IfTrue
if true then e1 else e2 --> e1

----------------------------------------- :: IfFalse
if false then e1 else e2 --> e2

----------------------------------------- :: App
(\ x : T . e) v  --> [ x |=> v ] e

----------------------------------------- :: AppEv
(ep1 (\ x : T . e)) (ep2 r)  --> cod ep2 ([ x |=> dom ep1 /\ ep2 r ] e)

dom ep1 /\ ep2 undefined
----------------------------------------- :: AppEvFail
(ep1 (\ x : T . e)) (ep2 r)  --> error

----------------------------------------- :: AppEvPartial
(ep (\ x : T . e1)) r  --> cod ep([ x |=> dom ep e2 ] e1)

----------------------------------------- :: Plus
n1 + n2  --> n1 :+: n2

n1 + v --> e
----------------------------------------- :: PlusEvL
ep n1 + v  --> e

n1 + n2 --> e
----------------------------------------- :: PlusEvR
n1 + ep n2  --> e

----------------------------------------- :: EqT
n == n  --> true

n1 =/= n2
----------------------------------------- :: EqF
n1 == n2  --> false

n1 == v --> e
----------------------------------------- :: EqEvL
ep n1 == v  --> e

n1 == n2 --> e
----------------------------------------- :: EqEvR
n1 == ep n2  --> e


i elem {1,2}
------------------------------------------ :: Proj
pi@i (e1 , e2) --> e_i

i elem {1,2}
------------------------------------------ :: ProjEv
pi@i (ep (e1 , e2)) --> Proj@i ep e_i


------------------------------------------ :: Ascr
ep1 (ep2 e) --> ep1 /\ ep2 e

ep1 /\ ep2 undefined
------------------------------------------ :: AscrFail
ep1 (ep2 e) --> ep1 /\ ep2 e

e1 --> e2
------------------------------------------ :: Context
C[e1] --> C[e2]

e --> error
------------------------------------------ :: ContextFail
C[e] --> C[error]






defns
Types :: '' ::=

defn
Gamma |- e : T :: :: Hastype :: Hastype {{com Typability relation }} 
by 

 (x : T) elem Gamma
---------------- :: Var
  Gamma |- x : T

-------------- :: Bool
  Gamma |- b : Bool

-------------- :: Nat
  Gamma |- n : Nat 

  Gamma |- e1 : Nat
  Gamma |- e2 : Nat
  -------------- :: Plus
  Gamma |- e1 + e2 : Nat 

  Gamma |- e1 : Nat
  Gamma |- e2 : Nat
  -------------- :: Bool
  Gamma |- e1 == e2 : Nat


  Gamma , ( x : T1) |- e : T2
-------------- :: Lam
  Gamma |- \ x : T1 . e : T1 -> T2 

  Gamma |- e1 : T1 -> T2
  Gamma |- e2 : T1
-------------- :: App
  Gamma |- e1 e2 : T2

  Gamma |- e : Bool
  Gamma |- e1 : T
  Gamma |- e2 : T
  ---------------- :: If
  Gamma |- if e then e1 else e2 : T  


  Gamma |- e1 : T1
  Gamma |- e2 : T2
  --------------- :: Pair
  Gamma |- (e1 , e2 ) : T1 * T2

  Gamma |- e : T1 * T2
  i elem {1,2}
  --------------- :: Proj
  Gamma |- p@i e : T


  Gamma |- e : T2
  ep |- T1 ~=~ T2
  --------------- :: Ascr
  Gamma |- ep e : T1

defn
ep |- T1 ~=~ T2 :: :: Consistent :: Consistent {{com Type Consistency relative to Evidence }} 
by 

T3 /\ T1 ==== T3
T3 /\ T2 ==== T3
----------------- :: Ev
<< T3 >> |- T1 ~=~ T2

defn
T1 /\ T2 ==== T3 :: :: Meet :: Meet {{com Precision Meet }} {{tex [[T1]] \sqcap [[T2]] = [[T3]]}}
by 

------------- :: DynL
? /\ T ==== T

------------- :: DynR
T /\ ? ==== T

-------------- :: Refl
T /\ T ==== T 

T1 /\ T1' ==== T1''
T2 /\ T2' ==== T2''
--------------- :: Fun
T1 -> T2 /\ T1' -> T2' ==== T1'' -> T2'' 

T1 /\ T1' ==== T1''
T2 /\ T2' ==== T2''
--------------- :: Prod
T1 * T2 /\ T1' * T2' ==== T1'' * T2'' 

defn
[[ e ]] k ==== t :: :: Transform :: Transform
by

---------------------------- :: Var
[[x]] k ==== k[x]

---------------------------- :: Bool
[[b]] k ==== k [(DYN, b)]


---------------------------- :: Num
[[n]] k ==== k [(DYN, n)]

c fresh
[[e]] c ==== t
---------------------------- :: Fun
[[ (\ x : T . e) ]] k ==== k [(DYN, \ x c . t )]

k1 := ( \x2 . let y1 = pi1 x1 in let z1 = pi2 x1 in let y2 = pi1 x2 in let z2 = pi2 x2 in t1 )
t1 := DOM [y1, \y1' . DOM [ y1, \y1''. MEET [y1', y2, (\ y3 . z1 [(y3, z2), (\z3 . k [(y1'', z3)] ) ] )]]]
[[e2]] k1 ==== t'
[[e1]] (\ x1 . t' ) ==== t
---------------------------- :: App
[[ e1 e2 ]] k ==== t

k1 := ( \x2 . let z1 = pi2 x1 in let z2 = pi2 x2 in let z3 = z1 + z2 in k [z3] )
[[e2]] k1 ==== t'
[[e1]] (\ x1 . t' ) ==== t
---------------------------- :: Plus
[[ e1 + e2 ]] k ==== t

k1 := ( \x2 . let z1 = pi2 x1 in let z2 = pi2 x2 in let z3 = z1 == z2 in k [z3] )
[[e2]] k1 ==== t'
[[e1]] (\ x1 . t' ) ==== t
---------------------------- :: Eq
[[ e1 + e2 ]] k ==== t

[[e2]] (\ x2 . k [(DYN, (x1, x2))] ) ==== t'
[[e1]] (\ x1 . t' ) ==== t
---------------------------- ::Pair
[[ e1 + e2 ]] k ==== t

[[e1]] k ==== t1
[[e2]] k ==== t2
[[e0]] (\ x0 . let x = pi2 x0 in if x t1 t2 ) ==== t
---------------------------- :: If
[[ if e0 then e1 else e2 ]] k ==== t

[[e]] (\ x . let x' = pi@i x in k [x'] ) ==== t
---------------------------- ::Pair
[[ pi @ i e ]] k ==== t